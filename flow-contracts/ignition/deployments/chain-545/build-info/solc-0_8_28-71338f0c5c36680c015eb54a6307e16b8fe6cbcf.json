{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-71338f0c5c36680c015eb54a6307e16b8fe6cbcf",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/LetsPayFlow.sol": "project/contracts/LetsPayFlow.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/LetsPayFlow.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract LetsPayFlow {\n    address public owner;\n    uint256 public escrowCount;\n    uint256 public constant CREDIT_FLOW = 200 ether; // 200 FLOW tokens (assuming 1 FLOW = 1 ether unit)\n\n    mapping(address => uint256) public credit;\n    mapping(address => bool) public signedUp;\n    enum EscrowStatus {\n        CREATED,\n        PAID,\n        SETTLED,\n        CANCELLED\n    }\n\n    struct Escrow {\n        address host;\n        address payable merchant;\n        uint256 total;\n        EscrowStatus status;\n        address[] participants;\n        uint256[] shares;\n    }\n\n    mapping(uint256 => Escrow) public escrows;\n    mapping(uint256 => mapping(address => bool)) public accepted;\n\n    event SignedUp(address indexed user, uint256 amount);\n    event EscrowCreated(\n        uint256 indexed id,\n        address indexed host,\n        address indexed merchant,\n        uint256 total\n    );\n    event MerchantPaid(uint256 indexed id, address merchant, uint256 total);\n    event ParticipantAccepted(\n        uint256 indexed id,\n        address participant,\n        uint256 amount\n    );\n    event EscrowSettled(uint256 indexed id);\n    event ContractFunded(address indexed from, uint256 amount);\n    event CreditRepaid(address indexed user, uint256 amount);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"owner only\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // fund the contract with native FLOW so it can pay merchants\n    function fundContract() external payable {\n        require(msg.value > 0, \"no value\");\n        emit ContractFunded(msg.sender, msg.value);\n    }\n\n    // give user 200 FLOW credits \n    function signup() external {\n        require(!signedUp[msg.sender], \"already signed up\");\n        signedUp[msg.sender] = true;\n        credit[msg.sender] = CREDIT_FLOW;\n        emit SignedUp(msg.sender, CREDIT_FLOW);\n    }\n\n    // 1. deduct host credit by total\n    // 2. pay merchant directly\n    // 3. save escrow\n    // 4. build participants array = host + others\n    // 5. emit events\n    // 6. return escrow id\n    function createEscrow(\n        address payable merchant,\n        address[] calldata otherParticipants,\n        uint256[] calldata otherShares,\n        uint256 total\n    ) external returns (uint256) {\n        require(otherParticipants.length == otherShares.length, \"len mismatch\");\n\n        // compute host share = total - sum(otherShares)\n        uint256 sum = 0;\n        for (uint i = 0; i < otherShares.length; i++) {\n            sum += otherShares[i];\n        }\n        require(sum <= total, \"shares too big\");\n        uint256 hostShare = total - sum;\n\n        require(credit[msg.sender] >= hostShare, \"insufficient host credit\");\n\n        // Deduct host credit by total\n        credit[msg.sender] -= total;\n\n        // Pay merchant directly\n        require(address(this).balance >= total, \"contract lacks funds\");\n        (bool ok, ) = merchant.call{value: total}(\"\");\n        require(ok, \"merchant payment failed\");\n\n        // Save escrow\n        escrowCount++;\n        Escrow storage e = escrows[escrowCount];\n        e.host = msg.sender;\n        e.merchant = merchant;\n        e.total = total;\n        e.status = EscrowStatus.PAID;\n\n        // Build participants array = host + others\n        e.participants.push(msg.sender);\n        e.shares.push(hostShare);\n        for (uint i = 0; i < otherParticipants.length; i++) {\n            e.participants.push(otherParticipants[i]);\n            e.shares.push(otherShares[i]);\n        }\n\n        emit EscrowCreated(escrowCount, msg.sender, merchant, total);\n        emit MerchantPaid(escrowCount, merchant, total);\n\n        return escrowCount;\n    }\n\n    // 1. check if escrow is paid\n    // 2. check if host is not the participant\n    // 3. find the participant in the participants array\n    // 4. check if the participant has not accepted yet\n    // 5. deduct participant credit, reimburse host\n    // 6. accept participant\n    // 7. check if all participants have accepted\n    // 8. set escrow status to settled\n    // 9. emit events\n    // 10. return escrow id\n    function accept(uint256 escrowId) external {\n        Escrow storage e = escrows[escrowId];\n        require(e.status == EscrowStatus.PAID, \"not payable\");\n\n        // Host should never need to accept\n        require(msg.sender != e.host, \"host auto-paid\");\n\n        uint idx = type(uint).max;\n        for (uint i = 0; i < e.participants.length; i++) {\n            if (e.participants[i] == msg.sender) {\n                idx = i;\n                break;\n            }\n        }\n        require(idx != type(uint).max, \"not participant\");\n        require(!accepted[escrowId][msg.sender], \"already accepted\");\n\n        uint256 amount = e.shares[idx];\n        require(credit[msg.sender] >= amount, \"insufficient credit\");\n\n        // reduce participant credit, reimburse host\n        credit[msg.sender] -= amount;\n        credit[e.host] += amount;\n        accepted[escrowId][msg.sender] = true;\n\n        emit ParticipantAccepted(escrowId, msg.sender, amount);\n\n        // check if all participants (excluding host) have accepted\n        bool all = true;\n        for (uint i = 0; i < e.participants.length; i++) {\n            if (\n                e.participants[i] != e.host &&\n                !accepted[escrowId][e.participants[i]]\n            ) {\n                all = false;\n                break;\n            }\n        }\n        if (all) {\n            e.status = EscrowStatus.SETTLED;\n            emit EscrowSettled(escrowId);\n        }\n    }\n\n    function cancelEscrow(uint256 escrowId) external {\n        Escrow storage e = escrows[escrowId];\n        require(msg.sender == e.host || msg.sender == owner, \"not allowed\");\n        require(e.status == EscrowStatus.PAID, \"wrong state\");\n        e.status = EscrowStatus.CANCELLED;\n        credit[e.host] += e.total;\n    }\n\n    function getPendingEscrowsFor(\n        address user\n    ) external view returns (uint256[] memory) {\n        uint256 cnt = 0;\n        for (uint i = 1; i <= escrowCount; i++) {\n            Escrow storage e = escrows[i];\n            if (e.status == EscrowStatus.PAID) {\n                for (uint j = 0; j < e.participants.length; j++) {\n                    if (\n                        e.participants[j] == user &&\n                        e.participants[j] != e.host &&\n                        !accepted[i][user]\n                    ) {\n                        cnt++;\n                        break;\n                    }\n                }\n            }\n        }\n\n        uint256[] memory ids = new uint256[](cnt);\n        uint k = 0;\n        for (uint i = 1; i <= escrowCount; i++) {\n            Escrow storage e = escrows[i];\n            if (e.status == EscrowStatus.PAID) {\n                for (uint j = 0; j < e.participants.length; j++) {\n                    if (\n                        e.participants[j] == user &&\n                        e.participants[j] != e.host &&\n                        !accepted[i][user]\n                    ) {\n                        ids[k++] = i;\n                        break;\n                    }\n                }\n            }\n        }\n        return ids;\n    }\n\n    function escrowDetails(\n        uint256 escrowId\n    )\n        external\n        view\n        returns (\n            address host,\n            address merchant,\n            uint256 total,\n            EscrowStatus status,\n            address[] memory participants,\n            uint256[] memory shares\n        )\n    {\n        Escrow storage e = escrows[escrowId];\n        return (\n            e.host,\n            e.merchant,\n            e.total,\n            e.status,\n            e.participants,\n            e.shares\n        );\n    }\n\n    // get history of escrows for a user\n    function getUserHistory(\n        address user\n    )\n        external\n        view\n        returns (\n            uint256[] memory ids,\n            address[] memory hosts,\n            address[] memory merchants,\n            uint256[] memory totals,\n            EscrowStatus[] memory statuses,\n            address[][] memory participantsList,\n            uint256[][] memory sharesList\n        )\n    {\n        uint256 cnt = 0;\n        for (uint i = 1; i <= escrowCount; i++) {\n            Escrow storage e = escrows[i];\n            if (e.host == user) {\n                cnt++;\n            } else {\n                for (uint j = 0; j < e.participants.length; j++) {\n                    if (e.participants[j] == user) {\n                        cnt++;\n                        break;\n                    }\n                }\n            }\n        }\n\n        ids = new uint256[](cnt);\n        hosts = new address[](cnt);\n        merchants = new address[](cnt);\n        totals = new uint256[](cnt);\n        statuses = new EscrowStatus[](cnt);\n        participantsList = new address[][](cnt);\n        sharesList = new uint256[][](cnt);\n\n        uint k = 0;\n        for (uint i = 1; i <= escrowCount; i++) {\n            Escrow storage e = escrows[i];\n            bool involved = false;\n            if (e.host == user) {\n                involved = true;\n            } else {\n                for (uint j = 0; j < e.participants.length; j++) {\n                    if (e.participants[j] == user) {\n                        involved = true;\n                        break;\n                    }\n                }\n            }\n            if (involved) {\n                ids[k] = i;\n                hosts[k] = e.host;\n                merchants[k] = e.merchant;\n                totals[k] = e.total;\n                statuses[k] = e.status;\n                participantsList[k] = e.participants;\n                sharesList[k] = e.shares;\n                k++;\n            }\n        }\n    }\n\n    function repayCredit() external payable {\n        require(msg.value > 0, \"no value\");\n        credit[msg.sender] += msg.value;\n        emit CreditRepaid(msg.sender, msg.value);\n    }\n\n    // allow contract to receive FLOW\n    receive() external payable {}\n}\n"
      }
    }
  }
}